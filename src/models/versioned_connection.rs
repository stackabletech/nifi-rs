/*
 * NiFi Rest API
 *
 * The Rest API provides programmatic access to command and control a NiFi instance in real time. Start and                                             stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * The version of the OpenAPI document: 1.16.0
 * Contact: dev@nifi.apache.org
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct VersionedConnection {
    /// The component's unique identifier
    #[serde(rename = "identifier", skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
    /// The instance ID of an existing component that is described by this VersionedComponent, or null if this is not mapped to an instantiated component
    #[serde(rename = "instanceIdentifier", skip_serializing_if = "Option::is_none")]
    pub instance_identifier: Option<String>,
    /// The component's name
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The user-supplied comments for the component
    #[serde(rename = "comments", skip_serializing_if = "Option::is_none")]
    pub comments: Option<String>,
    #[serde(rename = "position", skip_serializing_if = "Option::is_none")]
    pub position: Option<Box<crate::models::Position>>,
    #[serde(rename = "source", skip_serializing_if = "Option::is_none")]
    pub source: Option<Box<crate::models::ConnectableComponent>>,
    #[serde(rename = "destination", skip_serializing_if = "Option::is_none")]
    pub destination: Option<Box<crate::models::ConnectableComponent>>,
    /// The index of the bend point where to place the connection label.
    #[serde(rename = "labelIndex", skip_serializing_if = "Option::is_none")]
    pub label_index: Option<i32>,
    /// The z index of the connection.
    #[serde(rename = "zIndex", skip_serializing_if = "Option::is_none")]
    pub z_index: Option<i64>,
    /// The selected relationship that comprise the connection.
    #[serde(rename = "selectedRelationships", skip_serializing_if = "Option::is_none")]
    pub selected_relationships: Option<Vec<String>>,
    /// The object count threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
    #[serde(rename = "backPressureObjectThreshold", skip_serializing_if = "Option::is_none")]
    pub back_pressure_object_threshold: Option<i64>,
    /// The object data size threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
    #[serde(rename = "backPressureDataSizeThreshold", skip_serializing_if = "Option::is_none")]
    pub back_pressure_data_size_threshold: Option<String>,
    /// The amount of time a flow file may be in the flow before it will be automatically aged out of the flow. Once a flow file reaches this age it will be terminated from the flow the next time a processor attempts to start work on it.
    #[serde(rename = "flowFileExpiration", skip_serializing_if = "Option::is_none")]
    pub flow_file_expiration: Option<String>,
    /// The comparators used to prioritize the queue.
    #[serde(rename = "prioritizers", skip_serializing_if = "Option::is_none")]
    pub prioritizers: Option<Vec<String>>,
    /// The bend points on the connection.
    #[serde(rename = "bends", skip_serializing_if = "Option::is_none")]
    pub bends: Option<Vec<crate::models::Position>>,
    /// The Strategy to use for load balancing data across the cluster, or null, if no Load Balance Strategy has been specified.
    #[serde(rename = "loadBalanceStrategy", skip_serializing_if = "Option::is_none")]
    pub load_balance_strategy: Option<LoadBalanceStrategy>,
    /// The attribute to use for partitioning data as it is load balanced across the cluster. If the Load Balance Strategy is configured to use PARTITION_BY_ATTRIBUTE, the value returned by this method is the name of the FlowFile Attribute that will be used to determine which node in the cluster should receive a given FlowFile. If the Load Balance Strategy is unset or is set to any other value, the Partitioning Attribute has no effect.
    #[serde(rename = "partitioningAttribute", skip_serializing_if = "Option::is_none")]
    pub partitioning_attribute: Option<String>,
    /// Whether or not compression should be used when transferring FlowFiles between nodes
    #[serde(rename = "loadBalanceCompression", skip_serializing_if = "Option::is_none")]
    pub load_balance_compression: Option<LoadBalanceCompression>,
    #[serde(rename = "componentType", skip_serializing_if = "Option::is_none")]
    pub component_type: Option<ComponentType>,
    /// The ID of the Process Group that this component belongs to
    #[serde(rename = "groupIdentifier", skip_serializing_if = "Option::is_none")]
    pub group_identifier: Option<String>,
}

impl VersionedConnection {
    pub fn new() -> VersionedConnection {
        VersionedConnection {
            identifier: None,
            instance_identifier: None,
            name: None,
            comments: None,
            position: None,
            source: None,
            destination: None,
            label_index: None,
            z_index: None,
            selected_relationships: None,
            back_pressure_object_threshold: None,
            back_pressure_data_size_threshold: None,
            flow_file_expiration: None,
            prioritizers: None,
            bends: None,
            load_balance_strategy: None,
            partitioning_attribute: None,
            load_balance_compression: None,
            component_type: None,
            group_identifier: None,
        }
    }
}

/// The Strategy to use for load balancing data across the cluster, or null, if no Load Balance Strategy has been specified.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LoadBalanceStrategy {
    #[serde(rename = "DO_NOT_LOAD_BALANCE")]
    DONOTLOADBALANCE,
    #[serde(rename = "PARTITION_BY_ATTRIBUTE")]
    PARTITIONBYATTRIBUTE,
    #[serde(rename = "ROUND_ROBIN")]
    ROUNDROBIN,
    #[serde(rename = "SINGLE_NODE")]
    SINGLENODE,
}

impl Default for LoadBalanceStrategy {
    fn default() -> LoadBalanceStrategy {
        Self::DONOTLOADBALANCE
    }
}
/// Whether or not compression should be used when transferring FlowFiles between nodes
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LoadBalanceCompression {
    #[serde(rename = "DO_NOT_COMPRESS")]
    DONOTCOMPRESS,
    #[serde(rename = "COMPRESS_ATTRIBUTES_ONLY")]
    COMPRESSATTRIBUTESONLY,
    #[serde(rename = "COMPRESS_ATTRIBUTES_AND_CONTENT")]
    COMPRESSATTRIBUTESANDCONTENT,
}

impl Default for LoadBalanceCompression {
    fn default() -> LoadBalanceCompression {
        Self::DONOTCOMPRESS
    }
}
/// 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ComponentType {
    #[serde(rename = "CONNECTION")]
    CONNECTION,
    #[serde(rename = "PROCESSOR")]
    PROCESSOR,
    #[serde(rename = "PROCESS_GROUP")]
    PROCESSGROUP,
    #[serde(rename = "REMOTE_PROCESS_GROUP")]
    REMOTEPROCESSGROUP,
    #[serde(rename = "INPUT_PORT")]
    INPUTPORT,
    #[serde(rename = "OUTPUT_PORT")]
    OUTPUTPORT,
    #[serde(rename = "REMOTE_INPUT_PORT")]
    REMOTEINPUTPORT,
    #[serde(rename = "REMOTE_OUTPUT_PORT")]
    REMOTEOUTPUTPORT,
    #[serde(rename = "FUNNEL")]
    FUNNEL,
    #[serde(rename = "LABEL")]
    LABEL,
    #[serde(rename = "CONTROLLER_SERVICE")]
    CONTROLLERSERVICE,
    #[serde(rename = "REPORTING_TASK")]
    REPORTINGTASK,
    #[serde(rename = "PARAMETER_CONTEXT")]
    PARAMETERCONTEXT,
    #[serde(rename = "TEMPLATE")]
    TEMPLATE,
}

impl Default for ComponentType {
    fn default() -> ComponentType {
        Self::CONNECTION
    }
}

