/*
 * NiFi Rest API
 *
 * The Rest API provides programmatic access to command and control a NiFi instance in real time. Start and                                             stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * The version of the OpenAPI document: 1.16.0
 * Contact: dev@nifi.apache.org
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct RemoteQueuePartitionDto {
    /// Total number of FlowFiles owned by the Connection
    #[serde(rename = "totalFlowFileCount", skip_serializing_if = "Option::is_none")]
    pub total_flow_file_count: Option<i32>,
    /// Total number of bytes that make up the content for the FlowFiles owned by this Connection
    #[serde(rename = "totalByteCount", skip_serializing_if = "Option::is_none")]
    pub total_byte_count: Option<i64>,
    /// Total number of FlowFiles that exist in the Connection's Active Queue, immediately available to be offered up to a component
    #[serde(rename = "activeQueueFlowFileCount", skip_serializing_if = "Option::is_none")]
    pub active_queue_flow_file_count: Option<i32>,
    /// Total number of bytes that make up the content for the FlowFiles that are present in the Connection's Active Queue
    #[serde(rename = "activeQueueByteCount", skip_serializing_if = "Option::is_none")]
    pub active_queue_byte_count: Option<i64>,
    /// The total number of FlowFiles that are swapped out for this Connection
    #[serde(rename = "swapFlowFileCount", skip_serializing_if = "Option::is_none")]
    pub swap_flow_file_count: Option<i32>,
    /// Total number of bytes that make up the content for the FlowFiles that are swapped out to disk for the Connection
    #[serde(rename = "swapByteCount", skip_serializing_if = "Option::is_none")]
    pub swap_byte_count: Option<i64>,
    /// The number of Swap Files that exist for this Connection
    #[serde(rename = "swapFiles", skip_serializing_if = "Option::is_none")]
    pub swap_files: Option<i32>,
    /// The number of In-Flight FlowFiles for this Connection. These are FlowFiles that belong to the connection but are currently being operated on by a Processor, Port, etc.
    #[serde(rename = "inFlightFlowFileCount", skip_serializing_if = "Option::is_none")]
    pub in_flight_flow_file_count: Option<i32>,
    /// The number bytes that make up the content of the FlowFiles that are In-Flight
    #[serde(rename = "inFlightByteCount", skip_serializing_if = "Option::is_none")]
    pub in_flight_byte_count: Option<i64>,
    /// The Node Identifier that this queue partition is sending to
    #[serde(rename = "nodeIdentifier", skip_serializing_if = "Option::is_none")]
    pub node_identifier: Option<String>,
}

impl RemoteQueuePartitionDto {
    pub fn new() -> RemoteQueuePartitionDto {
        RemoteQueuePartitionDto {
            total_flow_file_count: None,
            total_byte_count: None,
            active_queue_flow_file_count: None,
            active_queue_byte_count: None,
            swap_flow_file_count: None,
            swap_byte_count: None,
            swap_files: None,
            in_flight_flow_file_count: None,
            in_flight_byte_count: None,
            node_identifier: None,
        }
    }
}


